{"pages":[{"title":"all-categories","text":"","link":"/all-categories/index.html"},{"title":"all-tags","text":"","link":"/all-tags/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/09/03/hello-world/"},{"title":"컴파일, 인터프리터 언어","text":"컴파일 언어 소스코드에서 목적 코드로 옮기는 것을 말한다. 언어 종류 : C, C++, JAVA, C# 등 작성한 코드를 기계어로 변환하는 빌드의 과정을 거친 후 읽을 수 있게 만든다. 실행 파일을 생성한다. 빌드의 과정이 거쳐서 컴파일과 실행 단계가 분리되어 있음으로 빠르다. 오류가 있다면 컴파일할때 오류가 난다. 특징빌드타임에 모든 구문 분석과 기계어 변환이 이루어지기 때문에 빌드가 느리고 생성된 기계어는 정적이다. 하지만 런타임의 경우 특별한 과정이 없어서 빠르다. 인터프리터 언어 소스코드를 바로 실행하는 컴퓨터 프로그램 또는 환경을 말한다. 언어 종류 : javascript, html, 액션스크립트, sql, pyhone, ruby 등 작성한 코드를 빌드의 과정 없이 한줄 한줄 해석하여 명령을 실행한다. 실행파일을 따로 생성하지 않는다. 인터프리터 단계와 실행단계가 분리되어있지 않고 한줄 한줄 해석하기 때문에 빌드된 과정에 비해 다소 시간이 소요된다. 오류가 있다면 실행될때 오류가 난다. 특징한줄한줄 분석하여 실행속도가 느리지만 코드 변경시 즉시 실행이 가능하여 테스트에 용이합니다.","link":"/2019/10/01/concept/01_compiler_interpreter/"},{"title":"아스키코드,유니코드","text":"컴퓨터의 사용 2진수 컴퓨터의 기본 저장 단위는 바이트(byte)이다. 1바이트(byte)는 8비트(bit)이다. 1byte에는 2의 8승에 해당하는 256개의 고유한 값을 저장할 수 있다. 아스키(ASCII)아스키코드는 7비트 즉, 128개의 고유한 값만 사용한다.왜 아스키 코드는 7비트만 활용할까? 그 이유는 1비트를 통신 에러 검출을 위해 사용하기 때문이다. 0부터 32까지는 인쇄와 전송 제어용으로 사용되는 알 수 없는 용어들이 가득하다. 33부터 126까지는 숫자, 알파벳 소문자, 알파벳 대문자, 특수기호 등이 할당되어있는 것을 알 수 있다. 유니코드(Unicode)시간이 지나가면서 영어나 숫자 그리고 기본적인 기호뿐만 아니라 그 나라, 그 언어에서 쓰는 다양한 문자들을 처리하려면 1바이트로 정의된 아스키 코드를 확장할 필요가 있게 되었다. 유니코드는 이런 아스키코드의 한계성을 해소할 수 있는 체계로 만들어진 코드이다.각 나라별 언어를 모두 표현하기 위해 나온 코드 체계가 유니코드(Unicode)이다. 유니코드는 사용중인 운영체제, 프로그램, 언어에 관계없이 문자마다 고유한 코드 값을 제공하는 새로운 개념의 코드이다. 언어와 상관없이 모든 문자를 16비트로 표현하므로 최대 65,536자까지 표현할 수 있다.유니코드 인코딩 방식으로는 UTF-7, UTF-8, UTF-16, UTF-32 인코딩 등이 있다. 한글은 자음과 모음의 조합 가능 개수만 따져도 가뿐히 128개를 넘는다. 중국어 역시 한자의 개수가 만 개가 넘는데, 이를 어떻게 아스키 코드에 담을 수 있을까? 그래서 용량을 크게 확장한 2byte (2의 16승 = 65536)의 유니코드가 등장하게 되었다.","link":"/2019/10/01/concept/00_ascii-code_uini-code/"},{"title":"웹 동작 원리","text":"웹 브라우저는 어떻게 작동하는가?작동 순서 사용자 도메인 입력.비연결성 프로토콜의 특징을 가지고 있는 http는 규약에 따라 사용자의 도메인입력으로 요청(request) 준비를 한다. 먼저 접속하려고 하는 도메인에 연결된 DNS(네임서버)로 접속하여 서버 IP를 요청한다. 요청 받은 네임서버는 서버 IP주소를 찾은 뒤, 사용자 컴퓨터에게 IP를 알려준다.DNS 서버는, IP주소 변환 뿐만 아니라 위조된 사이트로 이동되는것을 막아주고 특정사이트에 접속되지 않거나 경고 메세지를 보여주는 페이지로 이동하는 등의 추가 동작을 한다. 컴퓨터는 전달 받은 서버 IP로 접속하여 도메인을 입력한 페이지의 정보를 요청(request)한다. 서버는 요청을 받아서 페이지(html,css,javascript)를 브라우저에 http의 규약에 따라 응답(reponse) 하여 준다. 브라우저는 응답받은 정보를 다운로드하여 파싱한다. html,css가 Rendering Engine에 의해 파싱되고, javascript가 javascript Engine에 의해 파싱되는데, 인터프리터 성격을 가진 이 언어들이 순서에 따라 파싱하여 랜더링된 후에 browser에 프린트되어진다.이때 태그의 위치에 따라 블로킹이 발생하여 DOM의 생성이 지연될 수 있기 때문에 script의 위치가 중요하다. 그래서 DOM이 완전히 생성 된 후 script가 실행될 수 있도록 body 최하단에 위치 시킨다. async 및 defer을 사용하면 html,css 파싱완료 후 실행할 수 있다. HTTP란?HTTP(Hypertext Transfer Protocol)란 브라우저 같은 응용 프로그램을 통해 사용자와 서버사이 데이터를 전송하는 프로토콜(통신 규약)로 WWW(World Wide Web)의 분산되어 있는 서버와 사용자간에 하이퍼 텍스트를 이용한 정보 교환이 가능하게 만든다. GET/ HTTP/ 1.1 ** -&gt; 요청 라인**Host : www.naver.com -&gt; 일반해더, 요청해더, 엔티티 헤더, crlfUser-Agent: Mozilla/5.0 HTTP/1.1 200 OK, 자원을 찾지못하면 404, 형식에 맞지않다면 400 REQUEST 특징 TCP(Transmission Control Protocol) / IP(Internet Protocol)을 이용하는 응용 프로토콜(application protocol)이다.컴퓨터와 컴퓨터간에 데이터를 전송 할 수 있도록 하는 장치로 인터넷을 통해 원하는 정보를 주고받는 기능을 이용하는 응용 프로토콜로 포트 번호는 기본적으로 80번을 사용한다. HTTP는 연결 상태를 유지하지 않는 비연결성 프로토콜이다.브라우저를 통해 사용자의 요청(request)에 따라 서버와 접속하여 요청에 대한 응답(response)의 데이터를 전송 후 연결을 종료한다.이러한 심플한 상태이기 때문에 전산 자원이 적게 든다는 장점이 있다.하지만 연결이 지속적이지 않기 때문에 사용자와 종료 후 추가적인 요청을 처리할 수없다는 단점이 있다.이러한 단점을 해소하기 위한 방법으로 Cookie, Session, URL Rewriting, Hidden Form Field 등이 사용된다. HTTP는 연결 상태를 유지하지 않는 프로토콜이기 때문에 요청(Request) / 응답(Response)방식으로 동작한다.서버가 먼저 응답하지 않으며 사용자의 요청 한개에 대해 한개의 응답을 하는 방식이다. 네임서버(DNS)란?사이트 접속을 하기 위해선, 해당 사이트에 대한 정보를 갖고 있는 서버의 주소. 즉 ip를 알아야 한다. 전세계적으로 무수히 많은 도메인에 연결된 ip를 알아내기란 쉽지않은데, 그래서 등작한 것이 바로 DNS(Domain Name Server)서버 이다. DNS 또는 Domain Name System은 사람이 읽을 수 있는 도메인 이름을 머신이 읽을 수 있는 ip주소 (ex: 192.0.4.2)로 변환한다.","link":"/2019/10/02/concept/03_web_works/"},{"title":"javascript VS ECMAScript","text":"ECMA Script란?MS의 Jscript와 javascript가 너무 재각각이라 표준이 필요하게 되었는데, 표준을 위해 자바스크립트를 ECMA(European Computer Manufacturers Assocation)라는 정보통신시스템 비영리 표준 기구에 제출하였고, 표준에 대한 작업을 ECMA-262란 이름으로 채택되었다. ECMA라는 단체에서 기존의 결점을 보완한 표준 자바스크립트 버전을 매년 발표한다. ES는 바로 EcmaScript의 줄임말이다. ECMAScript는 모두가 동일한 환경에서 볼 수 있게 구현된Javascript의 표준화된 언어. ES3(1999), ES5(2009), ES 2015(ES 6) JavascriptECMAScript 표준(ECMA-262)를 바탕으로 구현된언어. Javascript 가 실행되기 위해서는 Javascript Engine(interpreter)가 필요한다. 웹브라우저마다 다른 Javascript Engine을 가지고 있어서 ECMAScript spec차이가 생긴다. ECMA-262에서 정의하는 ECMAScript 핵심 기능을 제공 문서 객체모델 (DOM)을 웹페이지 콘텐츠를 조작하는 메서드와 인터페이스 제공 브라우저 객체 모델(BOM), 브라우저와 상호작용하는 메서드와 인터페이스를 제공.","link":"/2019/10/01/concept/02_javascript_ECMAScript/"},{"title":"키워드, 할당, 식별자","text":"키워드 (예약어)자바스크립트 코드를 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일정의 명령어이다. 자바스크립트 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행한다. var 키워드가 실행되면 자바스크립트 엔진은 새로운 변수를 선언한다. 키워드는 제어문의 시작과 끝, 특정한 조작 목적 등으로 쓰인다.이런 기능들이 정의되어 있기 때문에 식별자나 프로퍼티 이름으로 사용할 수 없다. 1break, case, catch, continue, debugger, default, delete, do, else, finally, for, function, if, in, instanceof, new, return, switch, this, throw, try, typeof, var void, while, with 할당변수(식별자)에 값을 저장하는 것을 할당(assignment 대입, 저장)이라고 한다. 변수를 선언하여 값을 할당하지 않았어도 값이 암묵적으로 undefined를 할당하여 초기화 된다. 식별자변수 이름을 식별자(identifier)라고도 부른다. 식별자는 어떤 값을 구별하여 식별해낼 수 있는 고유한 이름을 말한다. 식별자 라는 용어는 이름에만 국한해서 사용하지 않는다. 예를들어, 변수뿐만 아니라, 함수, 클래스 등의 이름은 모두 식별자다. 즉, 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 부른다. 식별자는 네이밍 규칙이 있다 식별자는 특수문자를 제외한 문자, 숫자, underscore( _ ), 달러 기호($)를 포함할 수 있다. 단, 식별자는 특수문자를 제외한 문자, underscore( _ ), 달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다. 예약어는 식별자로 사용할 수 없다.","link":"/2019/10/04/concept/04_keyword_assign_Identifier/"},{"title":"메모리와 메모리 구조","text":"메모리란 무엇인가여러개의 비트로 구성된 하나의 배열로 볼 수 있으며 우리는 여기에 무언가 읽고 쓸 수 있다. 8비트는 1바이트라고 하고 바이트가 모이면 워드가 된다. 메모리에는 많은것들이 저장된다. 프로그램에서 사용되는 모든 변수와 기타 데이터 운영체계 및 개별 프로그램의 코드 메모리 생존 주기메모리 할당(allocate) : 프로그램이 사용할 수 있도록 운영체계가 메모리를 할당한다. 저수준 언어에서는 개발자가 명시적으로 처리해줘야 하지만 자바스크립트 같은 고수준 언어에서는 자동으로 해준다. 메모리 사용(use) : 할당된 메모리를 실제 프로그램이 사용하는 단계. 개발자가 코드상에서 할당된 변수를 사용함으로써 읽기와 쓰기 작업이 이루어진다. 메모리 해제(release) : 프로그램에서 필요하지 않은 메모리 전체를 돌려주어 다시 사용가능하게 만드는 단계. 메모리 할당 작업과 마찬가지로 저수준 언어에서는 이를 명시적으로 처리해야한다. 자바스크립트는 가비지 컬렉터로 인해 자동적으로 처리한다. 자바스크립트에서의 메모리 할당자바스크립트는 개발자들의 메모리 할당의 책임에서 해방시켜주었다. 변수 선언 시점에 메모리 할당을 스스로 수행한다. 함수에서도 메모리 할당이 일어난다. 메모리 관리메모리가 더 이상 필요하지 않을 때 해제고수준의 언어에서는 가비지콜렉터(garbage collector)라는 소프트웨어가 내장되어 있는데 이것의 역할은 메모리 할당을 추적하고 메모리가 더 이상 필요 없어졌을 때 해제하는 작업을 한다. 이 작업은 근사한 작업인데 왜냐하면 어떤 메모리가 필요없는지 알아내는것을 알고리즘으로 풀 수 없는 비결정적인 문제이기 때문이다. 가비지 콜렉션‘더 이상 필요없는’ 모든 메모리를 찾는건 비 결정적이다. 따라서 몇가지 제한을 두어 ‘더 이상 필요없는 모든 메모리’가 아니라 ‘더 이상 필요없는 몇몇 메모리’를 찾아본다. 참조가비지 콜렉션 알고리즘의 핵심 개념은 참조이다. A라는 메모리를 통해 B라는 메모리에 접근한다면 B는 A에 참조된다 라고한다. prototype을 암시적으로 참조하고 그 오브젝트의 속성을 명시적으로 참조한다. 가비지 콜렉션은 어떤 오브젝트를 참조하는 다른 오브젝트가 하나도 없다면 그 오브젝트에 대해 가비지 콜렉션을 수행한다.","link":"/2019/10/04/concept/05_memory/"},{"title":"네이밍, 데이터 타입","text":"네이밍 규칙123456789101112// 카멜 케이스 (camelCase)var firstName;// 스네이크 케이스 (snake_case)var first_name;// 파스칼 케이스 (PascalCase)var FirstName;// 헝가리언 케이스 (typeHungarianCase)var strFirstName; // type + identifiervar $elem = $('.myClass'); // jQuery 데이터 타입자바스크립트의 모든 값은 데이터 타입을 갖는다. 데이터 타입은 값으 종류를 이야기 한다. 데이터 타입이 필요한 이유는 아래와 같다. 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해 값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해 메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정하기 위해 타입 분류 원시 타입(primitive type) 숫자(number) 타입: 숫자 (정수, 실수) 문자열(string) 타입: 문자열 불리언(boolean) 타입: 논리적 참(true)과 거짓(false) undefined 타입: 선언은 되었지만 값을 할당하지 않은 변수에 암묵적으로 할당되는 값 null 타입: 값이 없다는 것을 의도적으로 명시할 때 사용하는 값 Symbol 타입: ES6에서 새롭게 추가된 7번째 타입 객체 타입 (object/reference type): 객체, 함수, 배열 등","link":"/2019/10/07/concept/06_naming-datatype/"},{"title":"동적 타입 언어","text":"동적 타입언어동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있다. 이러한 동적 타입 언어의 특징은 데이터 타입에 대해 무감가해질 정도로 편리하다. 언제나 이 이면에는 위험도 도사리고 있다. 동적 데이터 타입은 변수의 값이 의도치 않게 변경될 수 있다. 변수의 데이터 타입이 고정되어 있지 않고 동적으로 변하는 동적 타입 언어는 변수가 저장하고 있는 값을 확인하기 전에는 값의 타입을 확신할 수 없다. 더욱이 자바스크립트는 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 즉, 숫자 타입의 변수일 것이라고 예측했지만 사실은 문자열 타입의 변수일 수 도 있다는 말이다. 잘못된 예측에 의해 작성된 프로그램은 당연히 오류를 뿜어낼 것이다. 동적 타입언어는 유연성은 높지만, 신뢰성은 떨어진다. 변수의 사용을 적극적으로 줄인다. 변수의 개수가 많으면 많을수록 오류가 발생할 확률은 높아진다. 전역 변수는 사용하지 않는다. 변수의 생명주기(스코프)를 최대한 짧게 만든다. (전역스코프를 사용하지 않는다) 변수보다는 상수를 사용해 값의 변경을 억제한다. 변수 이름은 변수의 존재 이유를 파악할 수 있도록 명명한다.","link":"/2019/10/07/concept/07_dynamic-language/"},{"title":"표현식과 값","text":"표현식과 값리터럴로 만들어진 것이 값이고, 값은 표현식이다. 결과적으로 표현식은 평가되어 값을 생성한다. 값은 더 이상 평가할 수 없는 하나의 표현식이다. 값은 프로그래밍 언어에 따로 유효한 값이 정해져 있다. 자바스크립트는 7가지 종류의 값, 다시말해 7가지 데이터 타입의 값이있다. 값은 다양한 방법으로 생성할 수 있는데 가장 기본적인 방법은 리터럴 표기법이다. 리터럴은 소스코드 안에서 직접 만들어 낸 고정된 값 자체를 말한다. 리터럴은 사람이 이해할 수 있는 표기법으로 값의 생성을 자바스크립트 엔진에게 명령하는 것이다. 문과 표현식표현식은 하나의 값으로 평가될 수 있는 문인데. 다양한 표현식이 있지만 하나의 값으로 평가된다는 점에서 동일하다.","link":"/2019/10/07/concept/08_expression-value/"},{"title":"단축 평가","text":"단축평가논리 || 연산자와 논리곱 &amp;&amp; 연산자의 연산 결과는 불리언 값이 아닐 수도 있다. 이 두 연산자는 언제나 피연산자 중 어느 한쪽 값을 반환한다. 첫번째 피연산자 ‘Cat’은 true로 평가된다. 이 시점에 두번째 피연산자까지 평가해 보지 않아도 위 표현식을 평가할 수 있다. 논리 연산자 || 는 논리 연산의 결과를 결정한 첫번째 피연산자 즉. 문자열 ‘Cat’을 그대로 반환한다. 단축 평가 표현식 평가 결과 true || anything true false || anything anything true &amp;&amp; anything anything false &amp;&amp; anything false 123456789// 논리합(||) 연산자'Cat' || 'Dog' // 'Cat'false || 'Dog' // 'Dog''Cat' || false // 'Cat'// 논리곱(&amp;&amp;) 연산자'Cat' &amp;&amp; 'Dog' // Dogfalse &amp;&amp; 'Dog' // false'Cat' &amp;&amp; false // false 함수를 호출할 때 인수를 전달하지 않으면 매개변수는 undefined를 갖는다. 이때 단축 평가를 사용하여 매개변수의 기본값을 설정하면 undefined로 인해 발생할 수 있는 에러를 방지할 수 있다.","link":"/2019/10/10/concept/09_short-evaluation/"},{"title":"internet network server","text":"브라우져와 서버간 request, response가 반복되는 것인 컴퓨터간의 대화라고 할 수 있다. request한 컴퓨터는 client라고하며, response한 컴퓨터는 server라고 한다. domain, ip address구글에 접근할 수 있는 방법 ip address, domaindomain name -&gt; google.comip adress -&gt; 216.58.197.174 (확인 방법 : ping google.com)google.com을 입력하여 전송을 누르면 ip address로 변환되서 ip address가 접속이되고 응답이 된다. 출력 경로google.com입력 &gt;DNS Server접속 &gt;DNS database에서 google.com의 ip주소를 client컴퓨터에 전송. &gt;client의 컴퓨터가216.58.197.174으로 ip로 접속해서 응답을 받는다. DNS Server란?google.com 같은 네임 주소를 입력 하면, DNS 서버에서 google.com의 숫자로 된 고유 ip 주소로 변경해서 접속 하게 됩니다.하지만 DNS 서버는 이 도메인을 ip 주소로 변환만 하는게 아니라, DNS 서버를 보유한 곳의 보안 정책이 적용 되어 있어서,google.com을 입력 하면 위조된 사이트로 이동되는 것도 막아주기도 하고,특정 사이트는 접속이 되지 않거나, 접속 하더라도 경고 페이지를 보여 주는 등의 추가 동작을 하기도 합니다. iphttp://ipinfo.io/ip : 220.117.71.146 (접속한 컴퓨터가 어떤 아이피로 접속했는지 결과적으로 확인함)ip addr : 10.0.2.15 (컴퓨터에 부여된 실제 ip, 컴퓨터가 실질적으로 가지고 있는 ip를 알아냄) public address : 회사에서 아이피 부여 ex) 220.117.71.146 회사의 대표번호와 같은private address: 외부에 공개되지않은, 내선번호와 같은 -&gt; 회사에서 ip주소를 부여하고 라우터가 중간에 있다면, 로컬 컴퓨터의 서버는 외부에서 접근할 수 없지만, 로컬컴퓨터 서로는 같은 wifi안에서 접근할 수 있다.","link":"/2019/09/03/internet/internet/"},{"title":"개발 환경 및 실행 환경","text":"자바스크립트 실행환경모든 브라우저는 자바스크립트를 실행할 수 있는 엔진을 가지고있다. node에서도 역시 작동한다. 브라우저와 node.js는 용도가 다르다. 차이점브라우저 : 클라이언트 사이드 Web API 제공node.js : node.js 고유의 api 웹 브라우저웹 브라우저는 어떻게 작동하는가?작동순서 사용자 도메인 입력 (사용자가 요청을 보냄) (브라우저의 핵심 역할은 html,css,javscript를 요청) http의 규약대로 통신하여 움직인다 DNS서버에서 ip주소로 변환하여 서버에 웹페이지를 요청(request) (DNS 서버는 IP주소 변환 뿐만 아니라 위조된 사이트로 이동되는것을 막아주고 특정사이트에 접속되지 않거나 경고 메세지를 보여주는 페이지로 이동하는 등의 추가 동작을 한다.) 서버의 응답을 받아(responsive) 브라우저에 표출 (브라우저는 서버로부터 html, css, javascript, 이미지 파일) 등 을 READ되어 응답, 다운로드 한다. 브라우저에 의해 HTML,CSS,javascript가 분석하기위해 파싱되어 웹페이지에 표시, 파싱(브라우저 랜더링앤진)의 결과물이 돔트리다. 이때 각 언어에 맞는 컴파일언어, 인터프리터 언어의 과정을 거치며 실행한다. 태그의 위치에 따라 블로킹이 발생하여 DOM의 생성이 지연될 수 있기때문에 script의 위치가 중요하기 떄문에 DOM이 완전히 생성 된 후 script가 실행될 수 있도록 body 최하단에 위치 시킨다. async 및 defer을 사용하면 파싱완료 후 실행할 수 있다. 후에 페인팅 한다. 개발자 도구elements : dom과 css를 편집하여 렌더링된 뷰를 볼 수 있다.console : 에러 및 console.log메소드 결과를 확인 할 수 있다.sources : 로딩된 웹 페이지의 자바스크립트 코딩을 디버깅 할 수있다.Network : 로딩 웹페이지에 관련 네트워크 요청 정보 및 퍼포먼스 확인할 수있다.Application : 웹 스토리지, 세션, 쿠키를 확인하고 관리할 수 있다. 콘솔에플리케이션이 정상적으로 동작하지 않을때 가장 우선적으로 살펴보아야한다. 에러가아니더라도 콘솔 함수를 사용하거나 자바스크립트 코드를 직접 입력하여 사용 할 수 있다. 1console.log(); 디버깅source패널에서 에러가 발생한 코드 왼쪽의 라인 번호를 클릭하여 브레이크 포인트(중단점)을 걸고 다시 버튼을 클릭하면 디버깅 모드에 들어가게 된다. source tab &gt; html클릭 &gt; 빨간색 밑줄의 x자에 에러메세지 나옴번호 왼쪽에 클릭 break를 걸고, 새로고침해서 실행하면 나온다. 참고사이트Tools for Web Developers:콘솔사용 : https://developers.google.com/web/tools/chrome-devtools/console/?hl=ko Tools for web Developers: Chrome Devtools 자바스크립트 디버깅 시작하기 : https://developers.google.com/web/tools/chrome-devtools/javascript/?hl=ko Node.jsReact와같은 라이브러리를 도입하거나 Babel, Webpack, ESlint 등 여러가지 를 사용할때 Node.js와 npm이 필요하다 Node.js와 npm브라우저 이외의 환경에서 동작 시킬 수 있는 자바스크립트 실행환경이 node.js이다. 주로 서버사이드 애플리케이션 개발에 사용되고 빌트인api를 제공한다. SPA(Single Page Application)에 적합하다. npm(node pakage manager)은 자바스크립트 패키지 매니저이다. node.js에서 사용할 수 있는 모듈들을 패키지화 하여 저장소 역할과 패키지 설치 및 관리를 위해 cli를 제공한다.","link":"/2019/10/01/javascript/00_development-environment/"},{"title":"variable (변수)","text":"변수 하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체를 말한다.-이름은 곳 그 공간의 위치를 알 수 있다. 하나의 값을 저장할 수 있고, 객체나 배열과 같은 자료 구조를 사용하면 여러개의 값을 하나로 그룹화 하여 하나의 값처럼 사용할 수 있다.-메모리가 하나의 방이기 때문에 하나의 값만 넣을 수 있다.-값은 메모리에 들어갈 대상.-여러개의 값을 하나로 그룹화하는것을 자료구조형이라고 한다.(객체, 배열)-고유한 아이디와 같다. 메모리에 얘랑 쟤를 다가르키면 안되니까-10+20 = 30 ex) var result = 10+20 이라면 결과값 30은 남겨두고 10과20은 가비지컬렉터에 의해 사라진다. (사용되지 않기때문에 지워진다); 저장된 값을 다시 읽어들여서 재사용 할 수 있도록 메모리 공간을 식별할 수 있는 이름을 붙힌 것이다.-변수의 이름은 값을 의미해야한다.(아기 이름 짓듯이)- 변수에 값을 저장하는 것을 할당(assignment대입, 저장) 이라고하고, 변수에 저장된 값을 읽어 들이는 것을 참조(reference)라고 한다 feat. 데이터를 다루는것.메모리 : 기억, 데이터를 저장, 방의 크기가 똑같음, 방은 각각 주소가있다. 이것을 메모리 address라고한다.cpu는 연산 : 10,20을 메모리에서 긁어와서 30이라는 결과를 만들어 넣는다.javascript는 메모리의 주소에 계속 쌓이기 때문에 변수를 선언하여 메모리 주소를 기억하게 한다. 식별자변수 이름을 식별자(identifer)라고 부른다. 식별자는 어떤 값을 구별하여 식별해낼 수 있는 이름을 말한다. 식별자의 예로는, 변수, 함수, 클래스 등의 이름이 모두 식별자 이다. 즉 값을 식별할 수 있는 이름은 모두 식별자 라고 부른다. feat. 변수 이름이 들어가는것을 식별자라고함. 함수 이름도 식별자다. 클래스 명도 식별자다. 식별자는 메모리에 저장되어있는 값의 주소를 알고있다. 모든 식별자는 메모리의 address를 갖는다. 값을 식별할 수 있다. 변수 선언var, let, const 키워드를 사용한다.var : function-scope, 이미 만들어진 변수를 재선언해도 오류가 발생하지 않는다.let : block-scope, 변수를 재선언하면 오류가 난다.const : 재선언 및 재할당 할 수 없다. var 키워드는 뒤에 오는 변수 이름으로 새로운 변수를 선언할 것을 지시하는 키워드이다. 1var score; // undefined 변수 선언 후 값을 할당하지 않았지만, 자바스크립트 엔진에 의해 undefined라는 값이 암묵적으로 할당되어 초기화된다. 이것은 자바스크립트의 독특한 특징이다. 자바스크립트 엔진은 변수 선언을 2개의 단계를 거쳐 수행한다. 선언 단계 : 변수 이름을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다. 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당한다 변수를 사용하려면 반드시 선언이 필요하다. 변수 뿐만 아니라 모든 식별자(함수, 클래스 등)이 그렇다. 그렇지 않으면 error가 발생한다. feat. 변수란? 메모리의 공간을 변수라한다. 그 공간에는 변수의 이름이 붙어있다. 메모리 공간을 변수라고 한다.변수의 이름을 선언해서 자바스크립트에 변수의 공간 확보를 요청한다. 1234var result = 100; //선언과 할당. 선언을 하지않으면 메모리 공간 확보가 되지 않기때문에 할당되지 않는다.var result; //선언만하고 값을 할당하지않으면 자바스크립트가 암묵적으로 undefined값을 준다.undefined; 변수 선언의 실행 시점과 변수 호이스팅12console.log(score); // undefinedvar score; //변수 선언 (변수선언문) 변수 선언은 소스 코드가 순차적으로 한 줄씩 실행되는 시점, 즉 런타임이 아니라 그 이전 단계인 구문분석(syntax analysis) 단계에 먼저 실행된다. (즉 코드를 한줄씩 순차적으로 실행하기 이전에 먼저 코드 전체를 평가한다) 이때 모든 선언문 (변수 선언문, 함수 선언문 등)을 찾아내어 식별자를 등록하고 초기화 한다. 그 후 선언문을 제외한 소스 코드를 한 줄씩 순차적으로 실행한다. 변수선언(선언 단계와 초기화 단계)이 소스코드가 순차적으로 실행되는 런타임 이전인 구문 분석 단계에 먼저 실행 된다. 이처럼 변수 선언문 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라 한다. 12console.log(score); //선언이 되어있냐 안되어있냐var score; //변수 선언(선언문) feat. 자바스크립트가 변수 선언문을 만나면 인터프리터가 코드를 실행하기 이전에 모든 선언문만을 먼저 실행한다. 선언문이 하는 일은 식별자를 만든다. (실행문이 가장 먼저!) 코드가 실행될 수 있는 환경을 만든다. 선언문이 먼저 자바스크립트 엔진에 등록한다. 후에 인터프리터가 선언문을 제하고 실행한다. 변수 호이스팅. 선언문만 먼저 실행되고 할당문은 인터프리터가된다. 왜 호이스팅이 발생하는가? 먼저 선언해서. 값의 할당변수에 값을 할당할 때는 이전 값 undefined가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당된 값을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그 메모리 공간에 값을 할당하는것이다. 값을 재할당 하여도 공간을 지우는것이 아니라 값을 새롭게 저장하는 것이다. 아무도 사용하지 않는 재할당 된값 이전의 값들은 가비지 컬렉터에 의해 메모리에서 자동 해제된다. 가비지 컬렉터(Garbage Collector)가비지 컬렉터는 애플리케이션이 확보한 메모리를 주기적으로 검사하여 더 이상 사용되고 있지 않는 메모리를 해제하는 기능을 말한다. 더 이상 사용되고 있지 않는 메모리란 어떤 식별자도 참조하고 있지 않는 메모리 영역을 의미한다. 자바스크립트는 가비지 컬렉터를 내장하고 있는 매니지드 언어이다. 이를 통해 메모리 누수(memory leak)를 방지한다. feat. 원시값은 메모리의 값을 지우지않고 새로 추가한다. 값을 변경할 수 없다. 지우고 다시쓰는 애들은 객체라고 한다. 원시 값은 수정할 수 없다. 메모리에 들어간 값을 바꿀 수 없다. 가비지 컬렉터는 확보된 메모리 공간을 풀어주는 역할을 한다.","link":"/2019/10/01/javascript/01_variable/"},{"title":"data-type","text":"feat. 식을 평가해서 값을 만든다. 데이터타입자바스크립트의 모든 값은 데이터 타입을 갖는다. 데이터 타입은 값으 종류를 이야기 한다. 데이터 타입이 필요한 이유는 아래와 같다. 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해 값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해 메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정하기 위해 feat. 모든 값은 타입이 있다.자바스크립트 타입을 사용하는 이유 타입을 알아야 메모리 공간을 확보할 수 있다.-몇 바이트 가지고 와야 하는지 타입을알아야함-값을 가지고 왔는데 그 값을 어떻게 해석해야하는가-타입마다 확보해야할 메모리 공간의 차이가 제 각각 이다.-8바이트 단위로 가져와야함. 식별자가 알고있어야 한다. 값값은 더 이상 평가할 수 없는 하나의 표현식이다. 평가의 결과물은 값이다. 이것을 표현식이라고 한다. 표현식은 평가되어 하나의 값을 만든다. 더 이상 평가할 수 없는것을 값이라고 한다. 이항연산자피연산자가 두개인것 단항연산자피연산자가 하나인것 리터럴 표기법리터럴을 이용해서 값을 만들어내는것을 리터럴 표기법이라고 한다. 값을 만들어내는 가장 기본적인 방식30이라고 쓴 그자체를 리터럴 표기법으로 값의 생성을 지시하였다. 표현식리터럴로 만들어진 값. 표현식은 하나 이상의 리터럴, 하나이상의 연산자로 이루어져 있는 문이다. 값을 만들어내는 방식이다. 표현식은 평가가 되는데 자바스크립트엔진에 의해서 평가되어 30이라는 새로운 값을 만들어 낸다. 값을 생성하는 문이다. 1var sum = 10 + 20; //10 + 20을 평가한 후에 30이 만들어 진다. 값의 생성값은 다양한 방법으로 생성할 수 있는데 가장 기본적인 방법은 리터럴 표기법이다. 리터럴 리터럴은 소스 코드 안에서 직접 만들어 낸 고정된 값 자체를 말한다. 리터럴은 사람이 이해할 수 있는 표기법으로 값의 생성을 자바스크립트 엔진에게 명령하는 것이다. ex) 숫자, 문자열, 불리언, null, undefined, 객체, 배열, 함수, 정규 표현식 등 값과 리터럴의 관계1var score = 100; 리터럴은 자바스크립트 엔진에 의해 값으로 평가되므로 결국 리터럴은 값이라고 할 수 있다. 100은 리터럴이자 값이므로 변수에 할당할 수 있다. 1var score = 50 + 50; 값을 생성하는 문을 표현식이라고 한다. 표현식표현식은 하나의 값으로 평가될 수 있는 문이다. 데이터 타입의 분류원시타입(primitive type) 숫자 타입 : 숫자(정수, 실수) 문자열 타입 : 문자열 불리언 타입 : 논리적 참과 거짓-진위값(if문) undefined 타입 : 선언은 되었지만 값을 할당하지 않은 변수에 암묵적으로 할당되는 값 null 타입: 값이 없다는 것을 의도적으로 명시할 때 사용하는 값-변수에 값이 없다. 라고 표현 (의도적 부재) symbol 타입 : es6에서 새롭게 추가된 7번째 타입 객체 타입: 객체, 함수, 배열 등 객체형, 객체타입 1console.log(`1+1 = ${1+1}`) // 1+1=2 문자열 2로 표시됨, 암묵적 타입 변환이 됨. 타입변환이 빈번히 발생됨. 동적 타입언어, 정적타입언어값에 타입이 있다. 동적타입언어1234var a;typeof.a //undefinedvar a = 10;typeof.b //number 타입이 바뀐다. 근본적인 차이. 정적타입언어는 선언시 타입을 선언함으로 다른 타입을 선언 할 수 없다.동적타입언어는 타입을 변경 할 수 있다. 정적타입언어","link":"/2019/10/02/javascript/02_data-type/"},{"title":"연산자","text":"표현식과 연산자표현식은 리터럴, 식별자, 연산자, 함수/메소드 호출 표현식 등으로 나누어볼 수 있지만 결과적으로 하나의 값을 만든다는 점에서 모두 동일하다. 123var x = 10;// 표현식 + 30은 식별자 표현식과 숫자 리터럴과 연산자의 조합으로 구성되어 있다.x + 30; // -&gt; 40 문과 표현식문(statement)은 하나 이상의 표현식과 키워드의 조합으로 구성된 자바스크립트 엔진에게 내리는 명령이다. 문의 집합으로 이루어진 것이 바로 프로그램이며 문을 작성하고 순서에 맞게 나열하는것이 프로그램이다. 자바스크립트의 모든 코드는 문 또는 표현식이다. 표현식은 그 자체로 문이 될 수 있지만, 문이 표현식이 될 수 없다. 표현식의 역할은 값을 생성하는 것이다. 문의 역할은 표현식으로 생성한 값을 사용해 자바스크립트 엔진에게 명령을 내리는 것이다 표현식인 문과 표현식이 아닌 문변수 선언문은 값으로 평가될 수 없다. 따라서 표현식이 아닌 문이다. 하지만 할당문은 그 자체가 표현식인 문이다. 표현식인 문과 표현식이 아닌 문을 구별하기 위한 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다 1234567var x; // 변수 선언문은 표현식이 아닌 문이다.x = 100; // 할당문 자체가 표현식이지만 완전한 문이기도 하다. 즉 할당문은 표현식인 문이다.var foo = var x; // 표현식이 아닌 문은 값처럼 사용할 수 없다.var foo = x = 100; // 표현식인 문은 값처럼 사용할 수 없다.console.log(foo); //100 연산자란?하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입 연산 등을 수행해 하나의 값을 만든다. 이때 연산의 대상을 피연산자라고 한다. 연산자는 값으로 평가된 피연산자를 연산해 새로운 값을 만든다. feat. 피연산자는 표현식이면 된다. 이항 산술 연산자2개의 피연산자를 산술연산하여 값을 만든다.피연산자의 갑슬 변경하는 부수 효과는 없다. 언제나 새로운 값을 만든다. 1+, -, *, /, % 단항 산술 연산자1개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다. 이항 산술 연산자와는 달리 증가/감소(++/–) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다.. 다시 말해 증가/감소 연산을 하면 피연산자의 값이 바뀐다. 1++, --, +, - 문자열 연결 연산자+ 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.. 그 외의 경우 덧셈 연산자로 동작한다. 12'1' + 2; // -&gt; '12'1 + '2'; // -&gt; '12' 할당 연산자할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 할당 연산자는 좌항의 변수에 값을 할당하므로 변수의 값이 변하는 부수 효과가 있다. 12345// =, +=, -=, *=, /=, %=var x;x += 5; // x = x + 5;x -= 5; // x = x - 5; 비교연산자비교연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값을 반환한다. 비교 연산자는 if 문이나 for문과 같은 제어문의 조건식에서 주로 사용한다. 동등 / 일치 비교 연산자동등 비교 연산자와 일치 비교 연산자는 좌항과 우항의 피연산자가 같은 값을 갖는지 비교하여 불리언 값을 반환한다. 하지만 비교하는 엄격성의 정도가 다르다. 동등 비교 연산자는 느슨한 비교를 하지만 일치 비교 연산자는 엄격한 비교를 한다. 1==, ===, !=, !== 1234NaN === NaN; // -&gt; false;isNaN(NaN); //-&gt; true;isNaN(10); // -&gt; false;isNaN(1 + undefined); // -&gt; true; Nan은 자신과 일치하지 않는 유일한 값이다. 따라서 숫자가 NaN인지 조사하려면 빌트인 함수 isNaN을 사용한다. 대소 관계 비교 연산자대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다. 1&gt;, &lt;, &gt;=, &lt;= 삼항 조건 연산자1조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일때 반환할 값 123var x = 2;var result = x % 2 ? '홀수' : '짝수'; // 2 % 2는 0 이고 0은 false로 암묵적 타입이 변환된다.console.log(result); // 짝수 if else 문은 표현식이 아닌 문이라서 값처럼 사용할 수 없다.삼항조건 연산자는 표현식은 값으로 평가할 수 있는 표현식 문이다. 논리 연산자논리 연산자는 우항과 좌항의 피연산자를 논리 연산한다. 1||, &amp;&amp;, ! typeof 연산자123456789101112typeof '' // stringtypeof 1 // numbertypeof NaN // numbertypeof true // booleantypeof undefined // undefinedtypeof Symbol() // symboltypeof null // objecttypeof [] // objecttypeof {} // objecttypeof new Date() // objecttypeof /test/gi // objecttypeof function (){} // function typeof 연산자로 null 값을 연산해 보면 ‘null’이 아닌 ‘object’를 반환하는 것에 주의해야한다. 이것은 자바스크립트의 첫번째 버그이다. null타입을 확인할 때 typeof 연산자를 사용하지 말고 일치 연산자(===)를 사용하도록 하자. 123var foo = null;typeof foo === null; // -&gt; false;foo === null; // -&gt; true; 지수 연산자ES7에서 새롭게 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 타입의 값을 반환한다. 제곱연산자","link":"/2019/10/02/javascript/03_operator/"},{"title":"제어문","text":"블록문0개 이상의 문을 중괄호로 묶은 것으로 코드 블록 또는 블록 이라고 부르기도 한다. 블록문 끝에는 세미콜론을 붙이지 않는다. 123{ //코드 블러 내 변수는 이 안에서만 사용 할 수 있다.} 제어문조건문조건식의 평가 결과에 따라 코드 블럭의 실행을 결정한다. if, else문조건식의 평가 결과가 참(true)일 경우, if 문 다음의 코드 블록이 실행된다. 거짓(false)일 경우, else 문 다음의 코드 블록이 실행된다. 조건식을 추가하고 싶으면 else if 문을 사용한다. 삼항조건 연산자로 변경할 수 있다. switch 문12345678910switch(표현식) { case 표현식 1 : switch 문의 표현식 1이 일치하면 실행 break; case 표현식 2; switch 문의 표현식 2이 일치하면 실행 break; default : switch 문의 표현식과 일치하는 표현식을 갖는 case 문이 없을 때 실행될 문;} switch 문은 논리적 참, 거짓보다는 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용한다. case에 해당하는 문이 없다면 실행 순서는 default문으로 이동한다. 반복문for문 for 문을 실행하면 가장 먼저 변수 선언문 var i = 0이 실행된다. 변수 선언문은 단 한번만 실행된다. 변수 선언문의 실행이 종료되면 조건식으로 실행 순서가 이동한다. 현재 변수 i는 0이므로 조건식의 평가 결과는 true다. 조건식의 평가 결과가 true이므로 실행 순서가 코드 블록으로 이동하여 실행된다. 증감문으로 실행 순서가 이동하는 것이 아니라 코드 블록으로 실행 순서가 이동하는 것에 주의하자. 코드 블록의 실행이 종료하면 증감식으로 실행 순서가 이동한다. 증감식 i++가 실행되어 i는 1이 된다. 증감식 실행이 종료되면 다시 조건식으로 실행 순서가 이동한다. 변수 선언문으로 실행 순서가 이동하는 것이 아니라 조건식으로 실행 순서가 이동하는 것에 주의하자. 변수 선언문은 단 한번만 실행된다. 현재 변수 i는 1이므로 조건식의 평가 결과는 true다. 조건식의 평가 결과가 true이므로 실행 순서가 코드 블록으로 이동하여 실행된다. 코드 블록의 실행이 종료하면 증감식으로 실행 순서가 이동한다. 증감식 i++가 실행되어 i는 2가 된다. 증감식 실행이 종료되면 다시 조건식으로 실행 순서가 이동한다. 현재 변수 i는 2이므로 조건식의 평가 결과는 false다. 조건식의 평가 결과가 false이므로 for 문의 실행이 종료된다. while문while 문은 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다. 조건문의 평가 결과가 거짓이 되면 실행을 종료한다. do while문문은 코드 블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드 블록은 무조건 한번 이상 실행된다. break 문 break 문은 코드 블록을 탈출한다. 좀 더 정확히 표현하자면 코드 블록을 탈출하는 것이 아니라 레이블 문, 반복문(for, for…in, for…of, while, do…while) 또는 switch 문의 코드 블록을 탈출한다. 레이블 문, 반복문, switch 문의 코드 블록 이외에 break 문을 사용하면 SyntaxError(문법 에러)가 발생한다. continue 문continue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 이동한다. 문자열컴퓨터는 배열로 구분한다. 123var s = 'hello'// ['h','e','l','l','o'];// s[0] 유사 배열 객체 1'hello'.length //객체 처럼사용하면 객체로 변환해준다. 객체가 될 수 도 있다. 유사 배열 객체. 문자열은 for문으로 돌릴 수 있다. 한글자 한글자 씩 읽어 들일 수 있다.","link":"/2019/10/07/javascript/04_control-statement/"},{"title":"타입 변환과 단축 평가","text":"타입변환이란?자바스크립트의 모든 값은 타입이 있다. 값의 타입은 개발자의 의도에 의해 다른 타입으로 변환할 수 있다. 개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅 이라 한다. 1234var x = 10;// 명시적 타입변환var str = x.toString();console.log(typeof str, str); // string 10 동적 타입 언어인 자바스크립트는 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 이를 암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)이라고 한다. 12345var x = 10;// 암묵적 타입 변환// 문자열 연결 연산자는 숫자 타입 x의 값을 바탕으로 새로운 문자열을 생성한다.var str = x + '';console.log(typeof str, str); //string 10 문자열 타입으로 변환121+ '2' // '12'console.log(`1+1=${1+1}`); // \"1+1=2\" 숫자 타입 변환1231 - '1' // 01 * '10' // 10 1 / 'one' // NaN 불리언 타입 변환1234567// 아래의 조건문은 모두 코드 블록을 실행한다.if (!false) console.log(false + ' is falsy value');if (!undefined) console.log(undefined + ' is falsy value');if (!null) console.log(null + ' is falsy value');if (!0) console.log(0 + ' is falsy value');if (!NaN) console.log(NaN + ' is falsy value');if (!'') console.log('' + ' is falsy value'); 문자열 타입으로 변환 String 생성자 함수를 new 연산자 없이 호출하는 방법 Object.prototype.toString 메소드를 사용하는 방법 문자열 연결 연산자를 이용하는 방법 12console.log(1); //'1'console.log((1).toString()); //'1'console.log(1+''); // '1'; 숫자 타입으로 변환 Number 생성자 함수를 new 연산자 없이 호출하는 방법 parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능) + 단항 연결 연산자를 이용하는 방법 * 산술 연산자를 이용하는 방법 1console.log(Number(&apos;1&apos;)); //1console.log(parseInt(&apos;-1&apos;)); //-1console.log(+&apos;-1&apos;); // -1console.log(&apos;0&apos; * 1); // 1 불리언 타입으로 변환 Boolean 생성자 함수를 new 연산자 없이 호출하는 방법 ! 부정 논리 연산자를 두번 사용하는 방법 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법// 문자열 타입 =&gt; 불리언 타입console.log(Boolean('x')); // trueconsole.log(Boolean('')); // falseconsole.log(Boolean('false')); // true// 숫자 타입 =&gt; 불리언 타입console.log(Boolean(0)); // falseconsole.log(Boolean(1)); // trueconsole.log(Boolean(NaN)); // falseconsole.log(Boolean(Infinity)); // true// null 타입 =&gt; 불리언 타입console.log(Boolean(null)); // false// undefined 타입 =&gt; 불리언 타 입console.log(Boolean(undefined)); // false// 객체 타입 =&gt; 불리언 타입console.log(Boolean({})); // trueconsole.log(Boolean([])); // trueconsole.log(Boolean('x')); // trueconsole.log(Boolean('')); // falseconsole.log(Boolean('false')); // true// 숫자 타입 =&gt; 불리언 타입console.log(Boolean(0)); // falseconsole.log(Boolean(1)); // trueconsole.log(Boolean(NaN)); // falseconsole.log(Boolean(Infinity)); // true// null 타입 =&gt; 불리언 타입console.log(Boolean(null)); // false// undefined 타입 =&gt; 불리언 타 입console.log(Boolean(undefined)); // false// 객체 타입 =&gt; 불리언 타입console.log(Boolean({})); // trueconsole.log(Boolean([])); // true// 2. ! 부정 논리 연산자를 두번 사용하는 방법// 문자열 타입 =&gt; 불리언 타입console.log(!!'x'); // trueconsole.log(!!''); // falseconsole.log(!!'false'); // true// 숫자 타입 =&gt; 불리언 타입console.log(!!0); // falseconsole.log(!!1); // trueconsole.log(!!NaN); // falseconsole.log(!!Infinity); // true// null 타입 =&gt; 불리언 타입console.log(!!null); // false// undefined 타입 =&gt; 불리언 타입console.log(!!undefined); // false// 객체 타입 =&gt; 불리언 타입console.log(!!{}); // trueconsole.log(!![]); // true 단축평가1Cat&apos; &amp;&amp; &apos;Dog&apos; // &apos;Dog&apos; 논리곱 연산자 &amp;&amp;는 두개의 피연산자가 모두 true로 평가될 때 true를 반환한다. 대부분의 연산자가 그렇듯이 논리곱 연산자도 왼쪽에서 오른쪽으로 평가가 진행된다. 1&apos;Cat&apos; || &apos;Dog&apos; // &apos;Cat&apos; 논리합 연산자 ||는 두개의 피연산자 중 하나만 true로 평가되어도 true를 반환한다. 대부분의 연산자가 그렇듯이 논리합 연산자도 왼쪽에서 오른쪽으로 평가가 진행된다. 단축 평가 표현식 평가 결과 true || anything true false || anything anything true &amp;&amp; anything anything false &amp;&amp; anything false","link":"/2019/10/07/javascript/05_type-conversion/"},{"title":"객체 리터럴","text":"객체란자바스크립트는 객체(object) 기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 거의 “모든 것”이 객체이다. 원시 타입을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다. 원시 타입의 값, 즉 원시 값은 변경 불가능한 값이지만 객체 타입의 값, 즉 객체는 변경 가능한 값이다. 자바스크립트의 객체는 키(key)와 값(value)으로 구성된 프로퍼티(property)들의 집합이다. 객체는 프로퍼티와 메소드로 구성된 집합체이다. 프로퍼티와 메소드의 역할은 아래와 같다. 프로퍼티 : 객체의 상태를 나타내는 값. 메소드 : 프로퍼티를 참조하고 조작할 수 있는 동작 feat. 객체는 내가 가지고 있는 재산일 수도 있고 부모가 가지고있는 재산일 수 있다. = {} 리터럴 표기법코드블럭이면 새미콜론을 붙히지 않고, 값일때만 코드블럭을 붙힌다. {}하나의 값이다. 식별자는 스코프 체인이라는 곳에서 찾는다. {}의 프로퍼티는 프로토 타입 체인에서 찾는다. 프로퍼티의 값은 모두 올 수 있다. 프로퍼티에 함수가 오면 메서드라 부른다.프로퍼티는 스테이트 객체의 상태, 메소드는 그 상태를 조작한다.this는 자신이 포함되어있는 객체를 일컬음 객체 리터럴에 의한 객체 생성자바스크립트는 다양한 객체 생성 방법이 존재한다. 객체 리터럴 Object 생성자 함수 생성자 함수 Object.create 메소드 클래스 (ES6) 1var empty = {} feat 생성자 함수, 클래스에 의해 생성된 객체는 인스턴스라고 불러준다. 1var o = {}; //빈 객체 Object.__ __proto __ __ 아빠꺼 라는 뜻. 프로퍼티객체는 프로퍼티들의 집합이며 프로퍼티는 키와 값으로 구성된다. 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 symbol 값 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용하여야 한다 12345var person = { first_name: 'Ung-mo', 'last-name' : 'Lee'}console.log(person); last-name은 -의 네이밍 규칙을 준수하고 있지 않기 때문에 따옴표를 생략할 수 없다. 문자열 또는 문자열로 변환 가능한 값을 반환하는 표현식을 사용해 프로퍼티 키를 동적 생성할 수도 있다. 이경우에는 표현식을 대괄호로 묶어야 한다. 이를 계산된 프로퍼티 이름이라고 한다. 1234var obj = {};var key = 'hello';obj[key] = 'world';console.log(obj); // {hello:'world'} 빈 문자열로도 프로퍼티 키를 생성할 수 있다. 1234var foo = { '' : '' // 빈문자열도 프로퍼티 키로 사용할 수 있다.}console.log(foo); // {'':''} 프로퍼티 키에 문자열이나 symbol값 이외의 값을 사용하면 암묵적 타입 변환을 통해 문자열이 된다. 프로퍼티 키로 숫자 리터럴을 사용하면 따옴표는 붙지 않지만 내부적으로 문자열로 변환된다. 123456var foo = { 0:1, 1:2, 2:3}console.log(foo); 예약어를 프로퍼티 키로 사용해도 에러가 발생하지 않는다. feat. 프로퍼티 값에 숫자가 들어오면 문자열로 자동 형변환 해준다. 메소드자바스크립트의 함수는 객체이다. 따라서 함수는 값으로 취급할 수 있으며 프로퍼티의 값이 될 수 있다. 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드라고 부른다. 메소드는 객체에 제한되어 있는 함수를 의미한다. 프로퍼티 접근프로퍼티 값에 접근하려면 마침표를 사용하는 마침표 표기법, 혹은 대괄호 표기법을 사용한다. 프로퍼티 키가 식별자 네이밍 규칙을 따르는 이름, 즉 자바스크립트에서 사용 가능한 유효한 이름이면 마침표 표기법과 대괄호 표기법을 모두 사용할 수 있다. 12345678var person = { name: 'Lee'}// 마침표 표기법에 의한 프로퍼티 접근console.log(person.name); //Lee// 대괄호 표기법에 의한 프로퍼티 접근console.log(person['name']) //Lee 대괄호 표기법을 사용하는 경우, 대괄호 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다. 자바스크립트 엔진은 대괄호 내의 따옴표로 감싸지 않은 이름은 프로퍼티 키로 인식하지 않고 식별자로 취급한다. 프로퍼티 값 갱신이미 존재하는 프로퍼티 값을 할당하면 프로퍼티 값이 갱신된다. 12345ver person = { name : 'Lee'}person.name = 'Kim';console.log(person); // {name: \"Kim\"} 프로퍼티 동적 생성존재하지않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다. 1234567var person = { name: 'Lee'}person.address = 'Seoul';console.log(person); 프로퍼티 삭제delete 연산자는 객체의 프로퍼티를 삭제한다. 이때 delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 한다. 만약 존재하는 프로퍼티를 삭제하면 아무런 에러없이 무시된다. 123456789var person = { name : 'Lee'}//프로퍼티 동적 추가person.address = 'Seoul';delete person.address;console.log(person); // {name: 'Lee'} ES6에서 추가된 객체 리터럴의 확장기능프로퍼티 축약표현12345let x = 1, u = 2;const obj = {x, y};console.log(obj); // {x:1, y:2} 프로퍼티 키 동적 생성메소드 축약 표현","link":"/2019/10/07/javascript/06_object-literal/"},{"title":"원시 값과 객체의 비교","text":"원시 타입과 객체 타입은 근본적으로 다르다는 의미일 것이다. 원시 타입과 객체 타입은 크게 세가지 측면에서 다르다. 원시 타입의 값, 즉 원시 값은 변경 불가능한 값(immutable value)이다. 이에 비해 객체(참조) 타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다. 원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수에는 참조 값이 저장된다. 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달(Pass by value)라 한다. 이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달(Pass by reference)라 한다. 원시값변경 불가능한 값원시 타입의 값, 즉 원시 값은 변경 불가능한 값이다. 다시 말해, 한번 생성된 원시 값은 readonly한 값이므로 변경할 수 없다. 12345678const o = {};o.a = 1;console.log(o); // {a: 1}/* const 키워드를 사용해 선언한 상수는 재할당이 금지된다. 하지만 const 키워드를 사용해 선언한 상수에 할당된 객체는 변경할 수 있다. 즉 상수는 재할당이 금지된 변수일 뿐이다.*/ 원시 값은 변경 불가능한 값이기 때문에 값을 직접 변경할 수 없다. 따라서 변수의 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경한다. 원시 값의 이러한 특성을 불변성 이라 한다. 문자열과 불변성12var str = 'Hello';str = 'world'; 첫번째 문이 실행되면 메모리에 문자열 ‘Hello’가 생성되고 식별자 str은 문자열 ‘Hello’을 수정하는 것이 아니라 새로운 문자열 ‘world’를 메모리에 생성하고 식별자 str은 이것을 가리킨다. 이때 문자열 ‘Hello’와 ‘world’는 모두 메모리에 존재하고 있다. 식별자 str은 문자열 ‘Hello’를 가르키고 있다가 문자열 ‘world’를 가르키도록 변경되었을 뿐이다. 유사배열객체 : 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고, length 프로퍼티를 갖는 객체를 말한다. 값에 의한 전달변수에 변수를 할당하는 경우, 할당되는 변수(score)가 원시값을 갖는 변수라면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시값이 복사되어 전달된다. 이를 값에 의한 전달(Pass by value)라 한다. 객체참조값(Reference value) 참조 값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체이다. 123456789var person1 = { name : 'Lee'}var person2 = { name: 'Lee'}console.log(person1 === person2); //false : 참조값은 주소를 비교하고, 원시값은 값을 비교한다.console.log(person1.name === person2.name); //true 원시값이어서 값을 비교한다.","link":"/2019/10/09/javascript/07_primitive-value_object-compare/"},{"title":"함수","text":"함수란?자바스크립트에서 가장 중요한 핵심 개념은 함수다. 또 다른 자바스크립트의 핵심 개념인 스코프, 실행 컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메소드, this, 프로토타입, 모듈화 등이 모두 함수와 깊은 관련이 있다. 따라서 함수는 자바스크립트를 정확히 이해하고 사용하기 위해 피해갈 수 없는 핵심 중의 핵심이다. 함수의 사용이유 함수는 몇 번이든 호출할 수 있으므로 코드의 재사용이라는 측면에서 매우 유용하다. 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다. 함수는 코드의 가독성을 높힌다. 함수 리터럴 살펴보았듯이 리터럴 표기법(Literal notation)은 값을 생성하는 가장 기본적인 방법이다. 따라서 함수 리터럴도 평가되어 값을 생성하며 이 값은 객체다. 즉, 함수는 객체다. 함수 정의 함수 선언문 함수 표현식 생성자 함수 화살표 함수 함수 선언문함수 선언문은 함수 리터럴 표기법과 형태가 동일하다. 단, 함수 선언문은 함수 이름을 생략할 수 없다.함수 리터럴과 형식은 동일하지만 함수 선언문은 함수를 정의하는 “표현식이 아닌 문”으로 해석된다. 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 변수로 호출한다. 즉, 함수 선언문 방식으로 생성된 함수를 호출한 것은 함수 이름 add이 아니라 자바스크립트 엔진이 암묵적으로 생성한 변수 add인 것이다. 함수 이름과 변수 이름이 일치하므로 함수 이름으로 호출되는 듯 보이지만 사실은 변수로 호출된 것이다. 함수 표현식앞에서 언급했듯이 자바스크립트의 함수는 객체이다. 자바스크립트의 객체는 값처럼 변수에 할당 할 수도 있고 프로퍼티의 값이 될 수도 있으며 배열의 요소가 될 수도 있다. 이러한 객체를 일급 객체(first-class object)라 한다. 자바스크립트의 함수는 일급 객체이다. 함수가 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미다. 함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 함수 정의 방식을 함수 표현식(Function expression)이라 한다. 함수 선언문으로 정의한 함수 add를 함수 표현식으로 바꾸어 정의하면 아래와 같다. 함수 생성 시점과 함수 호이스팅함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다. 그러나 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다. 이는 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문이다. 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅(Function Hoisting)이라 한다. Function 생성자 함수자바스크립트가 기본 제공하는 빌트인 함수인 Function 생성자 함수는 매개변수 목록과 함수 몸체를 문자열로 전달받는다. new 연산자와 함께 호출하며 생성된 함수 객체를 반환한다. (사실 new 연산자 없이 호출하여도 결과는 동일하다.) 화살표 함수ES6에서 새롭게 도입된 화살표 함수(Arrow function)는 function 키워드 대신 화살표(=&gt;, Fat arrow)를 사용하여 보다 간략한 방법으로 함수를 선언할 수 있다. 화살표 함수는 항상 익명 함수로 정의한다. 함수 호출함수는 함수를 참조하는 변수와 한 쌍의 소괄호인 함수 호출 연산자로 호출한다. 함수 호출 연산자 내에는 0개 이상의 인수(argument)를 쉼표로 구분하여 나열한다. 이 인수는 매개변수에 할당할 수 있는 값이어야 한다. 매개변수와 인수함수의 실행을 위해 함수 외부에서 함수 내부로 값을 전달할 필요가 있는 경우, 매개변수(parameter, 인자)를 통해 인수(argument)를 전달한다. 인수는 함수를 호출할 때 지정하며 개수와 타입에 제한이 없다. 매개변수는 함수를 정의할 때 선언하며 함수 몸체 내부에서 변수와 동일하게 취급된다. 즉, 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고 변수와 마찬가지로 undefined로 초기화된 이후 인수가 할당된다. 함수가 호출될 때마다 매개변수는 이와 같은 단계를 거친다. arguments 객체 사실 초과된 인수가 그냥 버려지는 것은 아니다. 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다. 인수 확인 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다. 자바스크립트는 동적 타입 언어이다. 따라서 자바스크립트 함수는 매개변수의 타입을 사전에 지정하지 않는다. 매개변수의 개수이상적인 함수는 한가지 일만 해야 하며 가급적 작게 만들어야 한다.(클린 코드(로버트 C. 마틴 저)를 읽어보면 많은 것을 느낄 수 있다.) 따라서 매개변수는 최대 3개 이상을 넘지 않는 것을 권장한다. 만약 그 이상의 매개변수가 필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달받는 것이 유리하다. 외부 상태의 변경과 함수형 프로그래밍","link":"/2019/10/10/javascript/08_function/"},{"title":"스코프","text":"스코프란?스코프(Scope, 유효범위)는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적이며 중요한 개념이다. 스코프의 이해가 부족하면 다른 개념을 이해하기 어려울 수 있다. 더욱이 자바스크립트의 스코프는 다른 언어의 스코프와 다르게 동작하므로 주의가 필요하다. 그리고 var 키워드로 선언한 변수와 let 또는 const 키워드로 선언한 변수의 스코프도 다르게 동작한다. 스코프는 변수 그리고 함수와 깊은 관련이 있다. 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프(Scope, 유효범위)라 한다. 즉, 스코프는 식별자가 유효한 범위를 말한다. 스코프의 종류코드는 전역(global)과 지역(local)으로 구분할 수 있다. 구분 설명 스코프 변수 전역 코드의 가장 바깥 영역 전역 스코프 전역 변수 지역 함수 몸체 내부 지역 스코프 지역 변수 스코프 체인함수는 중첩될 수 있으므로 함수의 지역 스코프도 중첩될 수 있다. 이는 스코프는 함수의 중첩에 의해 계층적 구조를 갖는다는 것을 의미한다. 다시 말해 중첩 함수의 지역 스코프는 중첩 함수를 포함하는 외부 함수의 지역 스코프와 계층적 구조를 갖는다. 이때 외부 함수의 지역 스코프를 중첩 함수의 상위 스코프라 한다. 변수를 참조할 때, 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 이를 통해 상위 스코프에서 선언한 변수를 하위 스코프에서도 참조할 수 있다. 함수 레벨 스코프지역은 함수 몸체 내부를 말하고 지역은 지역 스코프를 만든다고 했다. 이는 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다는 의미이다. C나 Java 등 대부분의 프로그래밍 언어는 함수 몸체 만이 아니라 모든 코드 블록(if, for, while, try/catch 등)이 지역 스코프를 만든다. 이러한 특성을 블록 레벨 스코프(Block level scope)라 한다. 하지만 var 키워드로 선언된 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정한다. 이러한 특성을 함수 레벨 스코프(Function level scope)라 한다. ES6에서 도입된 let, const 키워드는 블록 레벨 스코프를 지원한다. 렉시컬 스코프 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정한다. 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다. 암묵적 전역 변수12345678function foo() { // 선언하지 않은 변수에 값을 할당하면 암묵적 전역 변수가 된다. x = 10;}foo();console.log(x); // 10 위 처럼 선언하지 않은 변수에 값을 할당하면 자바스크립트 엔진은 아무런 에러없이 암묵적으로 전역 변수를 선언하고 값을 할당한다.","link":"/2019/10/10/javascript/09_scope/"},{"title":"기본 개념과 동작원리 이해","text":"1const a = 123; //키워드 변수 연산자 값 프로그래밍이란프로그래밍이란 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션이다. 요구되는 것은 문제 해결 능력이다. 2진수는 0,1만표현 10진수는 0~9 까지 표현 8bit =&gt; 1bite =&gt; 256개 왜 8bit를 1bite라고할까?아스키코드 : 0과 1의 조합으로 사람이 이해할수 있는 숫자 문자를 만들어 내는 코드의 조합 경우 256 (영대소,숫자,특수문자)유니코드 : 문자는 2bite다","link":"/2019/10/01/javascript-basic/00_basic_content/"},{"title":"자바스크립트란?","text":"자바스크립트의 탄생넷스케이프 커뮤니케이션즈에서 브렌던 아이크(Brendan Eich)가 개발한 스크립트이다.Netscape Navigator 2에 탑재 되었고 “Mocha”로 명명되엇다. “Live script”에서 “javascript”로 명명되었다. ajax웹","link":"/2019/10/01/javascript-basic/01_what_javascript/"},{"title":"오리엔테이션","text":"프론트엔드 개발자가 하는일사용자 입력 &gt; 브라우저 &gt; 입력받은데이터 &gt; 서버로 보냄 &gt; 웹프라우저 &gt; 사용자이 과정을 웹 에플리케이션이라고 한다.브라우져가 자바스크립트를 동작시킨다. 웹 브라우져가 어떻게 움직이는지, html, css,javascript를 실행시키는지 알아야한다.서버에서도 javascript가 가능한데 그 플렛폼이 node.js이다. 어플리케이션을 사용하는 사람이 애플리케이션과 소통하기 위한 창구(user interface)를 사용하기 좋게 구현한다UI는 상태 정보를 서버로 전송하기도 하고 서버의 데이터를 가져와서 UI에 표시하기도 한다. 웹 에플리케이션 : 동적이다. 데이터가 백엔드와 왔다갔다하는가.웹 페이지 : 정적이다. State (상태관리)checkbox : true, false (두개이상 가능)radio: true,false (하나만 가능)input: 협업 툴을 잘 사용하는것 프론트엔드 개발에 필요한 기술 HTML CSS 크로스 브라우징 Javascript (es5, es6, ES Next, DOM/Event, Ajax, 동작원리(브라우저, 자바스크립트 엔진), nodejs) HTTP (통신 규약 -&gt; 데이터를 주고받을때 약속) Tool : Git, Webpack, Babel, ESlink, npm Library / TDD(Test Driver Development/ kama / jasmine, mocha, chai) 알고리즘, 자료구조 초심자가 경험하는 3가지 어려움 책이나 수업의 내용이 무슨 말인지 하나도 모르겠다. 주변 개발자의 말을 알아들을 수 없다. 어떻게 만들어야 할 지 감조차 오지 않는다. 어떻게 만들어야 할지는 알겠는데 막상 코딩하려니까 한 줄도 못 짜겠다. 프로그래밍 학습 방향기본 개념과 동작 원리 -&gt; 코딩 스킬 -&gt; 프로젝트","link":"/2019/10/01/javascript-basic/intro/"}],"tags":[],"categories":[{"name":"study","slug":"study","link":"/categories/study/"},{"name":"개념이해","slug":"study/개념이해","link":"/categories/study/개념이해/"},{"name":"internet","slug":"study/internet","link":"/categories/study/internet/"},{"name":"javascript","slug":"study/javascript","link":"/categories/study/javascript/"},{"name":"javascript-basic","slug":"study/javascript-basic","link":"/categories/study/javascript-basic/"}]}